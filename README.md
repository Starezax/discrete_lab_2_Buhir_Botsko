# Звіт щодо виокнання лабораторної роботи з криптографії.

## Огляд проєкту
Цей проєкт реалізує захищену систему обміну повідомлень за структурою клієнт-сервер з використанням RSA шифрування для захисту комунікації. 
Система складається з двох Python модулів:

1. Модуль клієнта, який підключається до сервера та відповідає за відправку/отримання зашифрованих повідомлень.
2. Модуль сервера, який керує підключеннями клієнтів та розсилає повідомлення між ними.

### Основні функції безпеки
- **RSA шифрування**: Всі повідомлення шифруються за допомогою криптографії з відкритим ключем RSA.
- **Цілісність повідомлень**: Перевірка геш-значення SHA-256 гарантує, що повідомлення не було змінено під час передачі.
- **Безпечна генерація ключів**: Генерація великих простих чисел (у діапазоні від 10^12 до 10^15) для створення пар ключів RSA.

### Генерація простих чисел

#### `compute_small_primes()`
Функція створює список всіх простих чисел до заданої межі (за замовчуванням межа становить 10 мільйонів)
використовуючи алгоритм решета Ератосфена:
1. Створюється масив `sieve`, де кожен елемент відповідає числу в діапазоні [0, limit]
2. Початково всі елементи встановлюються в 1.
3. Елементи 0 і 1 позначаються як не прості (встановлюються в 0).
4. Алгоритм ітерує від 2 до квадратного кореня з обмеження:
   - Якщо поточне число відмічене як просте, всі його кратні позначаються як не прості.
5. Функція повертає список індексів, які залишилися відміченими як прості.

Використовується байтова реалізація для оптимізації часової та просторової складності алгоритму.

#### `is_prime(num, k=5)`
Функція реалізує тест Міллера-Рабіна для перевірки простоти числа:
1. Розкладає число `num-1` у вигляді d·2^s, де d - непарне.
2. Виконує k раундів перевірки:
   - Обирає випадкове число a у діапазоні [2, num-1].
   - Обчислює x = a^d mod num.
   - Якщо x = 1 або x = num-1, переходить до наступного раунду.
   - Інакше повторює піднесення x^2 mod num до s-1 разів:
     - Якщо x = num-1 на будь-якому кроці, переходить до наступного раунду.
     - Якщо жодне піднесення не дає num-1, число вважається складеним.
3. Якщо число пройшло всі k раундів, воно вважається простим з високою ймовірністю.

#### `generate_large_prime()`
Функція генерує велике просте число у діапазоні від 10^12 до 10^15:
1. Отримує список малих простих чисел через виклик `compute_small_primes()`.
2. У безкінечному циклі:
   - Генерує випадкове число у заданому діапазоні.
   - Перевіряє, що число не ділиться на жодне мале просте число.
   - Використовує `is_prime()` для точної перевірки простоти.
   - Повертає число, якщо воно пройшло всі перевірки.

Коротко кажучи, цей підхід поєднує швидку фільтрацію за допомогою простого ділення та 
перевірку за допомогою тесту Міллера-Рабіна.

### Реалізація модуля клієнта

#### Клас `Client`

##### `__init__(self, server_ip: str, port: int, username: str)`
Конструктор класу клієнта:
1. Ініціалізує базові параметри клієнта: IP-адреса сервера, порт та ім'я користувача.
2. Викликає метод `generate_keys()` для створення пари ключів RSA.

##### `generate_keys(self)`
Метод створює пару ключів RSA для клієнта:
1. Генерує два великих простих числа p і q за допомогою `generate_large_prime()`.
2. Переконується, що p та q різні (якщо вони однакові, генерує нове q).
3. Обчислює модуль n = p·q.
4. Обчислює функцію Ейлера φ(n) = (p-1)·(q-1).
5. Вибирає випадкове число e у діапазоні [2, φ(n)), таке що НСД(e, φ(n)) = 1.
6. Обчислює d як мультиплікативне обернене до e за модулем φ(n).
7. Зберігає публічний ключ (e, n) та приватний ключ (d, n).

##### `rsa_encrypt(self, m_int, pub)` та `rsa_decrypt(self, c_int, priv)`
Базові методи для шифрування та розшифрування окремих блоків RSA:
- `rsa_encrypt`: обчислює c = m^e mod n, де (e, n) - публічний ключ.
- `rsa_decrypt`: обчислює m = c^d mod n, де (d, n) - приватний ключ.
- 
##### `encrypt_message(self, message: str, public_key: tuple)`
Метод шифрує повідомлення за допомогою публічного ключа отримувача:
1. Конвертує повідомлення у байти.
2. Обчислює максимальний розмір блоку, який можна шифрувати (залежить від розміру модуля n).
3. Розбиває повідомлення на блоки відповідного розміру.
4. Для кожного блоку:
   - Конвертує байти у ціле число.
   - Шифрує число за допомогою публічного ключа (c = m^e mod n).
   - Додає зашифроване число до списку результатів.
5. Повертає JSON-серіалізований список зашифрованих блоків.

##### `decrypt_message(self, encrypted_message: str, private_key: tuple)`
Метод розшифровує отримане повідомлення за допомогою власного приватного ключа:
1. Десеріалізує JSON-рядок у список зашифрованих блоків.
2. Для кожного блоку:
   - Конвертує рядок у ціле число.
   - Розшифровує число за допомогою приватного ключа (m = c^d mod n).
   - Визначає розмір блоку та конвертує ціле число назад у байти.
   - Додає байти до результуючого масиву.
3. Конвертує отриманий масив байтів назад у рядок UTF-8.

##### `init_connection(self)`
Метод ініціює підключення до сервера:
1. Генерує нову пару ключів RSA.
2. Створює сокет TCP та підключається до сервера.
3. Надсилає ім'я користувача серверу.
4. Отримує публічний ключ сервера та зберігає його.
5. Надсилає свій публічний ключ серверу.
6. Запускає два потоки:
   - `read_handler` для обробки вхідних повідомлень.
   - `write_handler` для обробки вихідних повідомлень.

##### `read_handler(self)`
Метод, що працює у окремому потоці та обробляє вхідні повідомлення:
1. У безкінечному циклі очікує на повідомлення від сервера.
2. Десеріалізує отримане повідомлення у формат JSON.
3. Розшифровує повідомлення за допомогою власного приватного ключа
4. Перевіряє цілісність повідомлення шляхом порівняння обчисленого SHA-256 гешу з отриманим гешем.
5. Якщо геші не співпадають, повідомлення ігнорується.
6. Інакше, виводить розшифроване повідомлення.

##### `write_handler(self)`
Метод, що працює у окремому потоці та обробляє вихідні повідомлення:
1. У безкінечному циклі очікує на введення користувача.
2. Обчислює SHA-256 геш повідомлення.
3. Шифрує повідомлення за допомогою публічного ключа сервера.
4. Формує JSON пакет, що містить геш та зашифроване повідомлення.
5. Надсилає пакет серверу.

### Реалізація модуля сервера

#### Клас `Server`

##### `__init__(self, port: int)`
Конструктор класу сервера:
1. Ініціалізує хост (127.0.0.1) та порт.
2. Створює порожні списки та словники для збереження:
   - Підключених клієнтів.
   - Імен користувачів.
   - Публічних ключів клієнтів.
3. Ініціалізує сокет TCP.
4. Викликає метод `generate_keys()` для створення пари ключів RSA сервера.

##### `generate_keys(self)`
Метод створює пару ключів RSA для сервера (аналогічно клієнтському методу):
1. Генерує два різних великих простих числа p і q.
2. Обчислює модуль n = p·q та функцію Ейлера φ(n) = (p-1)·(q-1).
3. Вибирає публічний експонент e, такий що НСД(e, φ(n)) = 1.
4. Обчислює приватний експонент d як мультиплікативне обернене до e за модулем φ(n).
5. Зберігає публічний ключ (e, n) та приватний ключ (d, n).

##### `rsa_encrypt(self, message_int: int, public_key: tuple)` та `rsa_decrypt(self, cipher_int: int, private_key: tuple)`
Базові методи для шифрування та розшифрування окремих блоків RSA (аналогічно клієнтським методам):
- `rsa_encrypt`: обчислює c = m^e mod n.
- `rsa_decrypt`: обчислює m = c^d mod n.

##### `encrypt_message(self, message: str, public_key: tuple)`
Метод шифрує повідомлення за допомогою публічного ключа отримувача (аналогічно клієнтському методу):
1. Конвертує повідомлення у байти.
2. Розбиває на блоки відповідно до максимально допустимого розміру.
3. Шифрує кожен блок окремо.
4. Повертає JSON-серіалізований список зашифрованих блоків.

##### `decrypt_message(self, encrypted_message: str, private_key: tuple)`
Метод розшифровує отримане повідомлення за допомогою власного приватного ключа (аналогічно клієнтському методу):
1. Десеріалізує JSON-рядок у список зашифрованих блоків.
2. Розшифровує кожен блок окремо.
3. Об'єднує розшифровані блоки.
4. Конвертує об'єднані байти у рядок UTF-8.

##### `start(self)`
Метод запускає сервер та очікує на підключення клієнтів:
1. Прив'язує сокет до вказаного хоста та порту.
2. Починає прослуховування з максимальною чергою 100 підключень.
3. У безкінечному циклі:
   - Приймає нове підключення клієнта.
   - Отримує ім'я користувача.
   - Зберігає інформацію про клієнта (сокет, ім'я).
   - Надсилає свій публічний ключ клієнту.
   - Отримує публічний ключ клієнта та зберігає його.
   - Запускає новий потік для обробки повідомлень від цього клієнта.

##### `broadcast(self, msg: str, sender=None)`
Метод розсилає повідомлення всім підключеним клієнтам, крім відправника:
1. Для кожного клієнта, окрім відправника:
   - Отримує публічний ключ клієнта.
   - Шифрує повідомлення за допомогою цього ключа.
   - Обчислює SHA-256 геш вихідного повідомлення.
   - Формує JSON пакет, що містить геш та зашифроване повідомлення.
   - Надсилає пакет клієнту.

##### `handle_client(self, c)`
Метод, що працює у окремому потоці та обробляє повідомлення від конкретного клієнта:
1. У безкінечному циклі очікує на повідомлення від клієнта.
2. При отриманні повідомлення:
   - Десеріалізує JSON пакет.
   - Отримує геш та зашифроване повідомлення.
   - Розшифровує повідомлення за допомогою приватного ключа сервера.
   - Перевіряє цілісність повідомлення шляхом порівняння гешів.
   - Якщо геші не співпадають, повідомлення ігнорується.
   - Інакше, формує нове повідомлення з додаванням імені відправника.
   - Розсилає це повідомлення всім іншим клієнтам.
3. Якщо клієнт відключився (отримано порожнє повідомлення), закриває з'єднання.

## Інструкція з використання

### Запуск сервера
```bash
python server.py
```
Сервер запуститься на localhost (127.0.0.1) порт 9001.

### Запуск клієнта
```bash
python client.py
```
1. Введіть бажаний нікнейм, коли буде запропоновано.
2. Почніть надсилати повідомлення.

## Висновки
Реалізована система забезпечує базову, але надійну чат-програму для захищеного обміну повідомленнями з використанням RSA шифрування.
Використання криптографії з відкритим ключем, разом з перевіркою цілісності повідомлень, забезпечує високий рівень захисту від прослуховування 
та модифікації повідомлень.
